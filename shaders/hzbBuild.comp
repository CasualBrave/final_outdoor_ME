#version 430 core
// Build a depth pyramid with selectable reduction (min/max).
layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, r32f) writeonly uniform image2D dstImage; // target level
layout(binding = 1) uniform sampler2D depthTex;   // source level 0 (depth buffer)
layout(binding = 2) uniform sampler2D pyramidTex; // source pyramid (previous level)

layout(location = 0) uniform int srcLevel; // -1 => use depthTex level 0, otherwise use pyramidTex at srcLevel
layout(location = 1) uniform int dstLevel;
layout(location = 2) uniform int reduceOp; // 0: min (nearest), 1: max (farthest)

void main() {
    ivec2 dstCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dstSize = imageSize(dstImage);
    if (dstCoord.x >= dstSize.x || dstCoord.y >= dstSize.y) return;

    // Level-0: direct copy (no 2x2 reduction).
    if (srcLevel < 0) {
        float d = texelFetch(depthTex, dstCoord, 0).r;
        imageStore(dstImage, dstCoord, vec4(d));
        return;
    }

    // Levels 1..N: map dst texel to 2x2 block in previous level, with edge replication.
    ivec2 srcSize = textureSize(pyramidTex, srcLevel);
    ivec2 base = dstCoord * 2;
    float m = (reduceOp == 0) ? 1.0 : 0.0; // depth in [0,1]
    for (int dy = 0; dy < 2; ++dy) {
        for (int dx = 0; dx < 2; ++dx) {
            ivec2 srcCoord = clamp(base + ivec2(dx, dy), ivec2(0), srcSize - ivec2(1));
            float d = texelFetch(pyramidTex, srcCoord, srcLevel).r;
            m = (reduceOp == 0) ? min(m, d) : max(m, d);
        }
    }
    imageStore(dstImage, dstCoord, vec4(m));
}
