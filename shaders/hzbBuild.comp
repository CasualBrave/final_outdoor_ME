#version 430 core
// Build min-based depth pyramid (nearest depth per tile)
layout(local_size_x = 8, local_size_y = 8) in;

layout(binding = 0, r32f) writeonly uniform image2D dstImage; // target level
layout(binding = 1) uniform sampler2D depthTex;   // source level 0 (depth buffer)
layout(binding = 2) uniform sampler2D pyramidTex; // source pyramid (previous level)

layout(location = 0) uniform int srcLevel; // -1 => use depthTex level 0, otherwise use pyramidTex at srcLevel
layout(location = 1) uniform int dstLevel;
layout(location = 2) uniform int reduceOp; // 0: min (nearest), 1: max (farthest)

void main() {
    ivec2 dstCoord = ivec2(gl_GlobalInvocationID.xy);
    ivec2 dstSize = imageSize(dstImage);
    if (dstCoord.x >= dstSize.x || dstCoord.y >= dstSize.y) return;

    // map dst texel to 2x2 block in source
    ivec2 base = dstCoord * 2;
    float m = (reduceOp == 0) ? 1.0 : 0.0; // depth in [0,1]
    for (int dy = 0; dy < 2; ++dy) {
        for (int dx = 0; dx < 2; ++dx) {
            ivec2 srcCoord = base + ivec2(dx, dy);
            float d;
            if (srcLevel < 0) {
                ivec2 srcSize0 = textureSize(depthTex, 0);
                if (srcCoord.x >= srcSize0.x || srcCoord.y >= srcSize0.y) continue;
                d = texelFetch(depthTex, srcCoord, 0).r;
            } else {
                ivec2 srcSize = textureSize(pyramidTex, srcLevel);
                if (srcCoord.x >= srcSize.x || srcCoord.y >= srcSize.y) continue;
                d = texelFetch(pyramidTex, srcCoord, srcLevel).r;
            }
            m = (reduceOp == 0) ? min(m, d) : max(m, d);
        }
    }
    imageStore(dstImage, dstCoord, vec4(m));
}
