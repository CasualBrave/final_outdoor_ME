#version 430 core

layout(local_size_x = 256) in;

struct InstanceData {
    mat4 model;
    vec4 sphere; // xyz center in world, w radius
};

layout(std430, binding = 0) readonly buffer InstanceBuffer {
    InstanceData instances[];
};

layout(std430, binding = 1) buffer VisibleBuffer {
    uint count;
    uint indices[];
};

layout(std430, binding = 2) buffer DrawCommand {
    uint count;
    uint instanceCount;
    uint firstIndex;
    uint baseVertex;
    uint baseInstance;
} drawCmd;

layout(location = 0) uniform uint numInstances;
layout(location = 1) uniform vec4 frustumPlanes[6];
layout(location = 9) uniform int useOcclusion;
layout(location = 10) uniform int fixedMipLevel;
layout(location = 11) uniform mat4 cullVP;
layout(location = 15) uniform vec2 screenSize;

layout(binding = 5) uniform sampler2D depthPyramid;

bool sphereInFrustum(vec3 center, float radius){
    // plane test (包含 far/near)
    for(int i=0;i<6;i++){
        float d = dot(frustumPlanes[i], vec4(center, 1.0));
        if(d < -radius){
            return false;
        }
    }
    return true;
}

void main(){
    uint idx = gl_GlobalInvocationID.x;
    if(idx >= numInstances) return;

    InstanceData inst = instances[idx];
    vec3 center = inst.sphere.xyz;
    float radius = inst.sphere.w;

    if(!sphereInFrustum(center, radius)) return;

    if (useOcclusion == 1) {
        vec4 clip = cullVP * vec4(center, 1.0);
        if (clip.w <= 0.0001) return;
        vec3 ndc = clip.xyz / clip.w;
        vec2 uv = ndc.xy * 0.5 + 0.5;
        if (uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0) return;
        float centerDepth = ndc.z * 0.5 + 0.5;
        float occDepth = textureLod(depthPyramid, uv, float(fixedMipLevel)).r;
        // conservative bias; allowed to use center only
        if (centerDepth > occDepth + 0.01) return;
    }

    uint writeIdx = atomicAdd(count, 1);
    indices[writeIdx + 1] = idx; // offset 1 reserved for count
    atomicAdd(drawCmd.instanceCount, 1);
}
